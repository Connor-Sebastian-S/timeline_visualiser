<!DOCTYPE html>
<html lang="en">
    <!-- Include Font Awesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

<!-- Optional Bootstrap CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #166088;
            --background-color: #f5f7fa;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --border-radius: 8px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: var(--background-color);
            padding: 20px;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            box-shadow: var(--box-shadow);
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .upload-container {
            background-color: white;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            margin-bottom: 20px;
        }

        .file-inputs {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }

        .file-input {
            flex: 1;
            min-width: 250px;
        }

        .file-input label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

        input[type="file"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f9f9f9;
        }

        button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0e4866;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--secondary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        #timeline-container {
            background-color: white;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            overflow: hidden;
            position: relative;
        }

        .timeline {
            position: relative;
            margin: 20px auto;
            padding: 20px 0;
        }

        .timeline-path {
            position: absolute;
            height: 4px;
            background-color: var(--primary-color);
            z-index: 1;
        }

        .timeline-connector {
    position: absolute;
    width: 4px;
    background-color: var(--primary-color);
    z-index: 1;
}

        #color-key-container {
    padding: 10px;
    background-color: white;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
}

#color-key-container h3 {
    margin-bottom: 10px;
}

#color-key li {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
}

#color-key li span:first-child {
    display: inline-block;
    width: 20px;
    height: 20px;
    margin-right: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
}


        .year-marker {
            position: absolute;
            width: 2px;
            background-color: #888;
            z-index: 0;
            display: none;
        }

        .year-label {
            position: absolute;
            font-size: 12px;
            color: #666;
            font-weight: bold;
            display: none;
        }

        .event-box {
            position: absolute;
            width: 150px;
            padding: 10px;
            background-color: var(--primary-color);
            color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            cursor: pointer;
            z-index: 2;
            transition: transform 0.2s;
        }

        .event-box:hover {
            transform: scale(1.05);
        }

        .event-date {
            font-weight: bold;
            font-size: 0.8rem;
        }

        .event-title {
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 10;
            overflow-y: auto;
        }

        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: var(--border-radius);
            width: 80%;
            max-width: 800px;
            position: relative;
        }

        .close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .modal-header {
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .modal-title {
            font-size: 1.5rem;
            color: var(--primary-color);
        }

        .modal-date {
            font-size: 0.9rem;
            color: #666;
        }

        .modal-description {
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .image-gallery {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            overflow-x: auto;
            padding-bottom: 10px;
        }

        .gallery-image {
            height: 100px;
            cursor: pointer;
            border-radius: 4px;
            transition: transform 0.2s;
        }

        .gallery-image:hover {
            transform: scale(1.05);
        }

        .fullscreen-image {
    display: none;  /* ✅ Hidden by default */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    z-index: 20;
    align-items: center;
    justify-content: center;
            cursor: pointer;
}

        .fullscreen-image img {
            max-width: 90%;
            max-height: 90%;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
            color: #666;
        }

        .error {
            background-color: #ffdddd;
            color: #d8000c;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
        }

        .media-section {
    margin: 20px 0;
    border-top: 1px solid #eee;
    padding-top: 15px;
}

.video-wrapper {
    margin: 10px 0;
    position: relative;
    padding-bottom: 56.25%; /* 16:9 aspect ratio */
    height: 0;
}

.video-wrapper iframe,
.video-wrapper video {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .file-inputs {
                flex-direction: column;
            }
            
            .modal-content {
                width: 95%;
                margin: 5% auto;
            }
            
            .event-box {
                width: 120px;
            }
        }
    </style>
</head>
<body>
    <div class="documentation-container" style="max-width: 800px; margin: 2rem auto; padding: 20px; background: #f8f9fa; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
    <h2 style="color: #166088; border-bottom: 2px solid #4a6fa5; padding-bottom: 0.5rem; margin-bottom: 1.5rem;">How to Prepare Your Timeline Files</h2>

    <div class="file-requirements">
        <!-- CSV Section -->
        <div class="csv-section" style="margin-bottom: 2rem;">
            <h3 style="color: #4a6fa5; margin-bottom: 1rem;">
                <i class="fas fa-file-csv" style="margin-right: 0.5rem;"></i>
                CSV File Requirements
            </h3>
            <div class="table-responsive" style="background: white; border-radius: 8px; padding: 1rem;">
                <table class="table table-sm" style="margin-bottom: 0;">
                    <thead style="background: #e9ecef;">
                        <tr>
                            <th>Column Name</th>
                            <th>Description</th>
                            <th>Example</th>
                            <th>Required</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td>ID</td><td>Unique numeric identifier</td><td>1, 2, 3</td><td><span class="badge bg-danger">Required</span></td></tr>
                        <tr><td>START_DATE</td><td>Start date (DD-MM-YYYY)</td><td>10-09-1396</td><td><span class="badge bg-danger">Required</span></td></tr>
                        <tr><td>END_DATE</td><td>End date</td><td>10-09-1396</td><td><span class="badge bg-success">Optional</span></td></tr>
                        <tr><td>NAME</td><td>Short event title</td><td>Battle of the North Inch</td><td><span class="badge bg-danger">Required</span></td></tr>
                        <tr><td>DESCRIPTION</td><td>Detailed description</td><td>30vs30 judicial combat...</td><td><span class="badge bg-success">Optional</span></td></tr>
                        <tr><td>TYPE</td><td>Category for coloring</td><td>Military, Political</td><td><span class="badge bg-success">Optional</span></td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- ZIP Section -->
        <div class="zip-section" style="margin-bottom: 2rem;">
            <h3 style="color: #4a6fa5; margin-bottom: 1rem;">
                <i class="fas fa-file-archive" style="margin-right: 0.5rem;"></i>
                ZIP File Structure
            </h3>
            <div style="background: #ffffff; border-radius: 8px; padding: 1rem; font-family: monospace;">
                <div>your-data.zip/</div>
                <div style="margin-left: 1rem;">
                    <div>├── 1/</div>
                    <div style="margin-left: 1rem;">
                        <div>│   ├── image1.jpg</div>
                        <div>│   ├── audio.mp3</div>
                        <div>│   └── videos.txt</div>
                    </div>
                    <div>├── 5/</div>
                    <div style="margin-left: 1rem;">│   └── battle.jpg</div>
                    <div>└── 17/</div>
                </div>
            </div>
            <div class="mt-3" style="margin-top: 1rem;">
                <strong>videos.txt format:</strong>
                <pre style="background: white; padding: 1rem; border-radius: 6px;">https://youtu.be/example1
https://vimeo.com/example2</pre>
            </div>
        </div>

        <!-- Tips Section -->
        <div class="usage-tips" style="background: #e3f2fd; padding: 1.5rem; border-radius: 8px;">
            <h4 style="color: #166088; margin-bottom: 1rem;">
                <i class="fas fa-lightbulb" style="margin-right: 0.5rem;"></i>
                Usage Tips
            </h4>
            <ul style="list-style: none; padding-left: 0;">
                <li style="margin-bottom: 0.5rem;"><i class="fas fa-check text-success"></i> Folders only needed for events with media</li>
                <li style="margin-bottom: 0.5rem;"><i class="fas fa-check text-success"></i> Keep filenames simple (avoid spaces)</li>
                <li style="margin-bottom: 0.5rem;"><i class="fas fa-check text-success"></i> Test video URLs before including</li>
                <li style="margin-bottom: 0.5rem;"><i class="fas fa-times text-danger"></i> Max image size: 500KB</li>
                <li style="margin-bottom: 0.5rem;"><i class="fas fa-times text-danger"></i> Max audio size: 2MB</li>
            </ul>
        </div>
    </div>
</div>
    
    <header>
        <h1>Timeline</h1>
        <p>Upload your CSV and optional ZIP file to visualise events on a timeline using the below upload buttons and then clicking "Load Timeline". Or, click "Load default Data" to see a sample timeline.</p>
    </header>

    <div class="upload-container">
        <div class="file-inputs">
            <div class="file-input">
                <label for="csv-file">CSV File (required):</label>
                <input type="file" id="csv-file" accept=".csv">
            </div>
            <div class="file-input">
                <label for="zip-file">ZIP File (optional):</label>
                <input type="file" id="zip-file" accept=".zip">
            </div>
        </div>
        <button id="load-button">Load Timeline</button>
        <button id="load-default-button">Load Default Data</button>
        <div id="error-container"></div>
    </div>

    <div class="controls">
        <div class="toggle-container">
            <span>Colour by Type:</span>
            <label class="toggle-switch">
                <input type="checkbox" id="color-toggle" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div id="color-key-container" style="display: none; margin-top: 10px;">
            <h3>Type Legend</h3>
            <div id="color-key" style="display: flex; flex-wrap: wrap; gap: 10px;"></div>
        </div>

    </div>

    <div id="timeline-container">
        <div id="loading" class="loading">Loading timeline...</div>
        <div id="timeline" class="timeline"></div>
    </div>

    <div id="event-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div class="modal-header">
                <h2 class="modal-title">Event Title</h2>
                <div class="modal-date">Event Date</div>
            </div>
            <div class="modal-description">Description will appear here.</div>
            <div class="image-gallery" id="image-gallery"></div>
        </div>
    </div>

    <div id="fullscreen-image-container" class="fullscreen-image">
        <img id="fullscreen-img" src="">
    </div>

    <script>
        // Global variables
        let eventData = [];
        let imageData = {};
        let colorByType = true;
        
        // DOM elements
        const csvFileInput = document.getElementById('csv-file');
        const zipFileInput = document.getElementById('zip-file');
        const loadButton = document.getElementById('load-button');
        const loadDefaultButton = document.getElementById('load-default-button');
        const colorToggle = document.getElementById('color-toggle');
        const timelineContainer = document.getElementById('timeline-container');
        const timeline = document.getElementById('timeline');
        const loading = document.getElementById('loading');
        const errorContainer = document.getElementById('error-container');
        const modal = document.getElementById('event-modal');
        const modalTitle = document.querySelector('.modal-title');
        const modalDate = document.querySelector('.modal-date');
        const modalDescription = document.querySelector('.modal-description');
        const imageGallery = document.getElementById('image-gallery');
        const fullscreenContainer = document.getElementById('fullscreen-image-container');
        const fullscreenImg = document.getElementById('fullscreen-img');
        
        // Hide loading initially
        loading.style.display = 'none';
        
        function parseCSV(text) {
            const rows = text.split('\n').filter(row => row.trim() !== '');
            const headers = rows[0].split(',').map(h => h.trim());
            const data = [];
        
            for (let i = 1; i < rows.length; i++) {
                const values = rows[i].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/); // Split on commas not inside quotes
                const entry = {};
                headers.forEach((header, index) => {
                    // Preserve ID as string
                    entry[header] = header === 'ID' 
                        ? values[index]?.trim().replace(/^"|"$/g, '') 
                        : values[index]?.trim().replace(/^"|"$/g, '');
                });
                data.push(entry);
            }
            return data;
        }
        
        async function handleZipFile(file) {
    try {
        const JSZip = window.JSZip;
        if (!JSZip) throw new Error("JSZip library not loaded");

        const zip = await JSZip.loadAsync(file);
        const mediaData = {};

        const processingPromises = [];

        zip.forEach((path, zipEntry) => {
            if (!zipEntry.dir) {
                const pathParts = path.split('/');
                if (pathParts.length > 1) {
                    const folderId = pathParts[0];
                    const fileName = pathParts[pathParts.length - 1];

                    // Create media entry if not exists
                    if (!mediaData[folderId]) {
                        mediaData[folderId] = {
                            images: [],
                            audio: [],
                            videos: []
                        };
                    }

                    // Process images
                    if (/\.(jpe?g|png|gif|bmp|webp)$/i.test(fileName)) {
                        processingPromises.push(processImage(zipEntry, folderId, fileName, mediaData));
                    }
                    // Process audio files
                    else if (/\.(mp3|wav|ogg)$/i.test(fileName)) {
                        processingPromises.push(processAudio(zipEntry, folderId, fileName, mediaData));
                    }
                    // Process video links file
                    else if (fileName.toLowerCase() === 'videos.txt') {
                        processingPromises.push(processVideos(zipEntry, folderId, mediaData));
                    }
                }
            }
        });

        await Promise.all(processingPromises);
        return mediaData;

        async function processImage(zipEntry, folderId, fileName, mediaData) {
            const content = await zipEntry.async('base64');
            const fileExt = fileName.split('.').pop().toLowerCase();
            const mimeType = {
                'jpg': 'image/jpeg',
                'jpeg': 'image/jpeg',
                'png': 'image/png',
                'gif': 'image/gif',
                'bmp': 'image/bmp',
                'webp': 'image/webp'
            }[fileExt] || 'image/jpeg';

            mediaData[folderId].images.push({
                name: fileName,
                data: `data:${mimeType};base64,${content}`
            });
        }

        async function processAudio(zipEntry, folderId, fileName, mediaData) {
            const content = await zipEntry.async('base64');
            const fileExt = fileName.split('.').pop().toLowerCase();
            const mimeType = {
                'mp3': 'audio/mpeg',
                'wav': 'audio/wav',
                'ogg': 'audio/ogg'
            }[fileExt] || 'audio/mpeg';

            mediaData[folderId].audio.push({
                name: fileName,
                data: `data:${mimeType};base64,${content}`
            });
        }

        async function processVideos(zipEntry, folderId, mediaData) {
            const content = await zipEntry.async('text');
            mediaData[folderId].videos = content.split('\n')
                .map(url => url.trim())
                .filter(url => url.length > 0);
        }

    } catch (error) {
        console.error('Error processing ZIP file:', error);
        showError('Error processing ZIP file: ' + error.message);
        return {};
    }
}
        
        // Function to generate a color based on the event type
        function getTypeColor(type) {
            if (!type) return '#4a6fa5'; // Default color
            
            // Generate a consistent color based on the type string
            let hash = 0;
            for (let i = 0; i < type.length; i++) {
                hash = type.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            // Convert to HSL to ensure good saturation and lightness
            const h = Math.abs(hash) % 360;
            const s = 60 + (Math.abs(hash) % 20); // 60-80% saturation
            const l = 40 + (Math.abs(hash) % 15); // 40-55% lightness
            
            return `hsl(${h}, ${s}%, ${l}%)`;
        }

function generateColorKey() {
    const colorKeyContainer = document.getElementById('color-key-container');
    const colorKey = document.getElementById('color-key');

    // Clear any previous keys
    colorKey.innerHTML = '';

    // Extract unique TYPE values from eventData
    const uniqueTypes = [...new Set(eventData.map(event => event.TYPE).filter(type => type !== ''))];


    // If there are no types, hide the legend
    if (uniqueTypes.length === 0 || !colorByType) {
        colorKeyContainer.style.display = 'none';
        return;
    }

    // Otherwise, show the container
    colorKeyContainer.style.display = 'block';

    uniqueTypes.forEach(type => {
        const color = getTypeColor(type);

        const item = document.createElement('div');
        item.style.display = 'flex';
        item.style.alignItems = 'center';
        item.style.gap = '8px';

        const colorBox = document.createElement('div');
        colorBox.style.width = '20px';
        colorBox.style.height = '20px';
        colorBox.style.backgroundColor = color;
        colorBox.style.border = '1px solid #aaa';
        colorBox.style.borderRadius = '4px';

        const label = document.createElement('span');
        label.textContent = type; 


        item.appendChild(colorBox);
        item.appendChild(label);

        colorKey.appendChild(item);
    });
}


function displayTimeline() {
    if (!eventData || eventData.length === 0) {
        showError('No event data to display.');
        return;
    }

    // Sort events by start date
    eventData.sort((a, b) => {
        const dateA = parseDate(a.START_DATE);
        const dateB = parseDate(b.START_DATE);
        return dateA - dateB;
    });

    // Clear the timeline
    timeline.innerHTML = '';

    // Calculate timeline dimensions
    const containerWidth = timelineContainer.clientWidth - 40; // Adjust for padding
    const eventBoxWidth = Math.min(150, containerWidth * 0.2);
    const eventBoxHeight = 70;
    const eventSpacing = 30;
    const rowHeight = eventBoxHeight + 60;
    const eventsPerRow = Math.max(3, Math.floor(containerWidth / (eventBoxWidth + eventSpacing)));

    // Find the earliest and latest dates
    let earliestDate = new Date();
    let latestDate = new Date(0);

    eventData.forEach(event => {
        const date = parseDate(event.START_DATE);
        if (date < earliestDate) earliestDate = date;
        if (date > latestDate) latestDate = date;
    });

    // Calculate start and end years
    const startYear = earliestDate.getFullYear();
    const endYear = latestDate.getFullYear();

    // Create year markers
    for (let year = startYear; year <= endYear; year++) {
        const yearPositions = calculateYearPosition(year, startYear, endYear, containerWidth, eventsPerRow, rowHeight);

        yearPositions.forEach(pos => {
            const marker = document.createElement('div');
            marker.className = 'year-marker';
            marker.style.left = `${pos.x}px`;
            marker.style.top = `${pos.y - 15}px`;
            marker.style.height = '15px';

            const label = document.createElement('div');
            label.className = 'year-label';
            label.style.left = `${pos.x - 15}px`;
            label.style.top = `${pos.y - 30}px`;
            label.textContent = year;

            timeline.appendChild(marker);
            timeline.appendChild(label);
        });
    }

    // Create timeline path segments and connectors
    const rowCount = Math.ceil(eventData.length / eventsPerRow);

    for (let row = 0; row < rowCount; row++) {
        const path = document.createElement('div');
        path.className = 'timeline-path';
        path.style.top = `${row * rowHeight + eventBoxHeight / 2}px`;
        path.style.left = '0';
        path.style.width = `${containerWidth}px`;
        timeline.appendChild(path);

        // Add vertical connector if not last row
        if (row < rowCount - 1) {
            const connector = document.createElement('div');
            connector.className = 'timeline-connector';
            connector.style.top = `${row * rowHeight + eventBoxHeight / 2}px`;
            connector.style.height = `${rowHeight}px`;
            connector.style.left = (row % 2 === 0) ? `${containerWidth}px` : '0px';
            timeline.appendChild(connector);
        }
    }

    // Create event boxes
    eventData.forEach((event, index) => {
        const row = Math.floor(index / eventsPerRow);
        const colInRow = index % eventsPerRow;

        // Snake pattern position calculation
        let left;
        if (row % 2 === 0) {
            // Left to right
            left = colInRow * (containerWidth / eventsPerRow);
        } else {
            // Right to left
            left = containerWidth - ((colInRow + 1) * (containerWidth / eventsPerRow)) + eventSpacing / 2;
        }

        const top = row * rowHeight;

        // Create the event box
        const eventBox = document.createElement('div');
        eventBox.className = 'event-box';
        eventBox.style.left = `${left}px`;
        eventBox.style.top = `${top}px`;
        eventBox.style.width = `${eventBoxWidth}px`;
        eventBox.style.height = `${eventBoxHeight}px`;

        // Set color based on TYPE if colorByType is enabled
        if (colorByType && event.TYPE) {
            eventBox.style.backgroundColor = getTypeColor(event.TYPE);
        }

        // Add date and title to event box
        const dateElem = document.createElement('div');
        dateElem.className = 'event-date';
        dateElem.textContent = formatDate(parseDate(event.START_DATE));

        const titleElem = document.createElement('div');
        titleElem.className = 'event-title';
        titleElem.textContent = event.NAME || 'Unnamed Event';

        eventBox.appendChild(dateElem);
        eventBox.appendChild(titleElem);

        // Add click event to show event details in modal
        eventBox.addEventListener('click', () => {
            showEventDetails(event);
        });

        // Add the event box to the timeline
        timeline.appendChild(eventBox);
    });

    // ✅ Generate the color key ONCE, after all event boxes are drawn
    if (colorByType) {
        generateColorKey();
    } else {
        document.getElementById('color-key-container').style.display = 'none';
    }

    // Set timeline height
    const totalHeight = rowCount * rowHeight;
    timeline.style.height = `${totalHeight}px`;
}

        
        // Calculate where a year should appear on the snake timeline
        function calculateYearPosition(year, startYear, endYear, width, eventsPerRow, rowHeight) {
            const yearPositions = [];
            const yearRange = endYear - startYear;
            const yearFraction = (year - startYear) / Math.max(1, yearRange);
            
            // Calculate total number of events to position this year
            const totalEventPositions = width * (yearFraction);
            const rowPosition = Math.floor(totalEventPositions / width);
            const positionInRow = totalEventPositions % width;
            
            // If it's an even row, position from left to right
            // If it's an odd row, position from right to left
            let x;
            if (rowPosition % 2 === 0) {
                x = positionInRow;
            } else {
                x = width - positionInRow;
            }
            
            yearPositions.push({
                x: x,
                y: rowPosition * rowHeight
            });
            
            return yearPositions;
        }
        
        // Helper function to parse date strings (DD-MM-YYYY)
        function parseDate(dateString) {
            if (!dateString) return new Date(0);
            
            const parts = dateString.split('-');
            if (parts.length === 3) {
                // DD-MM-YYYY format
                return new Date(parts[2], parts[1] - 1, parts[0]);
            } else {
                // Try as ISO format if the split failed
                return new Date(dateString);
            }
        }
        
        // Helper function to format dates
        function formatDate(date) {
            if (!(date instanceof Date) || isNaN(date)) return 'Unknown Date';
            
            const day = date.getDate().toString().padStart(2, '0');
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const year = date.getFullYear();
            
            return `${day}-${month}-${year}`;
        }
        
        // Function to show error messages
        function showError(message) {
            errorContainer.innerHTML = `<div class="error">${message}</div>`;
        }
        
        // Function to clear error messages
        function clearError() {
            errorContainer.innerHTML = '';
        }
        
        function showEventDetails(event) {
    modalTitle.textContent = event.NAME || 'Unnamed Event';
    modalDate.textContent = event.START_DATE || 'No date';
    modalDescription.textContent = event.DESCRIPTION || 'No description available.';

    // Clear previous media
    imageGallery.innerHTML = '';

    document.querySelectorAll('.media-section').forEach(section => {
        section.remove();
    });
            
    document.querySelectorAll('audio, video').forEach(mediaElement => {
        mediaElement.pause();
        mediaElement.removeAttribute('src');
        mediaElement.load();
    });
    
    const eventId = String(event.ID);
    const media = imageData[eventId] || { images: [], audio: [], videos: [] };

    // Show images
    if (media.images.length > 0) {
        media.images.forEach(img => {
            const imgElement = document.createElement('img');
            imgElement.className = 'gallery-image';
            imgElement.src = img.data;
            imgElement.alt = img.name;
            imgElement.addEventListener('click', () => showFullscreenImage(img.data));
            imageGallery.appendChild(imgElement);
        });
    } else {
        imageGallery.innerHTML = '<p>No images available.</p>';
    }

    // Add audio players
    if (media.audio.length > 0) {
        const audioSection = document.createElement('div');
        audioSection.className = 'media-section audio-section'; // Added specific class
        audioSection.innerHTML = '<h4>Audio Clips</h4>';
        
        media.audio.forEach(audio => {
            const audioElement = document.createElement('audio');
            audioElement.controls = true;
            audioElement.innerHTML = `
                <source src="${audio.data}" type="${audio.data.split(';')[0].split(':')[1]}">
                Your browser does not support audio elements.
            `;
            audioSection.appendChild(audioElement);
        });
        
        imageGallery.after(audioSection);
    }

    // Add video embeds
    if (media.videos.length > 0) {
        
        const videoSection = document.createElement('div');
        videoSection.className = 'media-section video-section'; // Added specific class
        videoSection.innerHTML = '<h4>Videos</h4>';
        
        media.videos.forEach(url => {
            const videoWrapper = document.createElement('div');
            videoWrapper.className = 'video-wrapper';
            
            if (url.match(/youtube\.com|youtu\.be/)) {
                const videoId = url.match(/(?:v=|\/)([a-zA-Z0-9_-]{11})/)[1];
                videoWrapper.innerHTML = `
                    <iframe 
                        src="https://www.youtube.com/embed/${videoId}" 
                        frameborder="0" 
                        allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" 
                        allowfullscreen>
                    </iframe>
                `;
            } else if (url.match(/vimeo\.com/)) {
                const videoId = url.match(/(\d+)/)[0];
                videoWrapper.innerHTML = `
                    <iframe 
                        src="https://player.vimeo.com/video/${videoId}" 
                        frameborder="0" 
                        allow="autoplay; fullscreen" 
                        allowfullscreen>
                    </iframe>
                `;
            } else {
                videoWrapper.innerHTML = `
                    <video controls>
                        <source src="${url}" type="video/mp4">
                        Your browser does not support HTML5 video.
                    </video>
                `;
            }
            
            videoSection.appendChild(videoWrapper);
        });
        
        imageGallery.after(videoSection);
    }

    modal.style.display = 'block';
}
        
        // Function to show a fullscreen image
        function showFullscreenImage(src) {
            fullscreenImg.src = src;
            fullscreenContainer.style.display = 'flex';
        }
        
        // Event listeners for the close buttons
        document.querySelector('.close').addEventListener('click', () => {
            modal.style.display = 'none';
        });
        
        fullscreenContainer.addEventListener('click', () => {
            fullscreenContainer.style.display = 'none';
        });
        
        // Close modal if clicking outside of content
        window.addEventListener('click', (event) => {
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        });
        
        // Toggle color by type
        colorToggle.addEventListener('change', () => {
            colorByType = colorToggle.checked;
            displayTimeline();
        });
        
        // Load button click event
        loadButton.addEventListener('click', async () => {
            const csvFile = csvFileInput.files[0];
            const zipFile = zipFileInput.files[0];
            
            clearError();
            
            if (!csvFile) {
                showError('Please select a CSV file.');
                return;
            }
            
            loading.style.display = 'block';
            
            try {
                // Load JSZip dynamically if needed
                if (zipFile && !window.JSZip) {
                    await loadJSZip();
                }
                
                // Read and parse CSV file
                const csvText = await csvFile.text();
                eventData = parseCSV(csvText);
                
                // Process ZIP file if provided
                if (zipFile) {
                    imageData = await handleZipFile(zipFile);
                } else {
                    imageData = {};
                }
                
                // Display the timeline
                displayTimeline();
            } catch (error) {
                console.error('Error loading files:', error);
                showError('Error loading files: ' + error.message);
            } finally {
                loading.style.display = 'none';
            }
        });
        
        // Load default data button click event
loadDefaultButton.addEventListener('click', async () => {
    clearError();
    loading.style.display = 'block';
    
    try {
        // Load JSZip dynamically if needed
        if (!window.JSZip) {
            await loadJSZip();
        }
        
        // Load default CSV data with proper error handling
        try {
            const csvResponse = await fetch('https://raw.githubusercontent.com/Connor-Sebastian-S/timeline_visualiser/main/timeline.csv');
            if (!csvResponse.ok) {
                throw new Error(`Failed to fetch CSV: ${csvResponse.status} ${csvResponse.statusText}`);
            }
            const csvText = await csvResponse.text();
            eventData = parseCSV(csvText);
        } catch (csvError) {
            console.error('Error loading default CSV:', csvError);
            showError('Error loading default CSV. Using empty dataset.');
            eventData = [];
        }
        
        // Reset image data if there's an error with the ZIP
        imageData = {};
        
        // Load default ZIP file with proper error handling
        try {
            const zipResponse = await fetch('https://raw.githubusercontent.com/Connor-Sebastian-S/timeline_visualiser/main/default.zip');
            if (!zipResponse.ok) {
                throw new Error(`Failed to fetch ZIP: ${zipResponse.status} ${zipResponse.statusText}`);
            }
            const zipBlob = await zipResponse.blob();
            imageData = await handleZipFile(zipBlob);
        } catch (zipError) {
            console.error('Error loading default ZIP:', zipError);
            showError('Error loading default images. Timeline will display without images.');
        }
        
        // Display the timeline even if only one of the files loaded successfully
        if (eventData.length > 0) {
            displayTimeline();
        } else {
            showError('No events to display. Please check the CSV file format.');
        }
    } catch (error) {
        console.error('Error in default data loading process:', error);
        showError('Error loading default data: ' + error.message);
    } finally {
        loading.style.display = 'none';
    }
});
        
        // Function to load JSZip library dynamically
        async function loadJSZip() {
            return new Promise((resolve, reject) => {
                if (window.JSZip) {
                    resolve();
                    return;
                }
                
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                script.onload = resolve;
                script.onerror = () => reject(new Error('Failed to load JSZip library'));
                document.head.appendChild(script);
            });
        }
        
        // Handle window resize to update the timeline layout
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (eventData.length > 0) {
                    displayTimeline();
                }
            }, 250);
        });
        
        // Load JSZip when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            loadJSZip().catch(error => {
                console.warn('JSZip preload failed, will try again when needed:', error);
            });
        });
    </script>
</body>
</html>
