<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #166088;
            --background-color: #f5f7fa;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --border-radius: 8px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: var(--background-color);
            padding: 20px;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            box-shadow: var(--box-shadow);
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .upload-container {
            background-color: white;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            margin-bottom: 20px;
        }

        .file-inputs {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }

        .file-input {
            flex: 1;
            min-width: 250px;
        }

        .file-input label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

        input[type="file"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f9f9f9;
        }

        button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0e4866;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--secondary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        #timeline-container {
            background-color: white;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            overflow: hidden;
            position: relative;
        }

        .timeline {
            position: relative;
            margin: 20px auto;
            padding: 20px 0;
        }

        .timeline-path {
            position: absolute;
            height: 4px;
            background-color: var(--primary-color);
            z-index: 1;
        }

        .timeline-connector {
    position: absolute;
    width: 4px;
    background-color: var(--primary-color);
    z-index: 1;
}

        #color-key-container {
    padding: 10px;
    background-color: white;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
}

#color-key-container h3 {
    margin-bottom: 10px;
}

#color-key li {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
}

#color-key li span:first-child {
    display: inline-block;
    width: 20px;
    height: 20px;
    margin-right: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
}


        .year-marker {
            position: absolute;
            width: 2px;
            background-color: #888;
            z-index: 0;
            display: none;
        }

        .year-label {
            position: absolute;
            font-size: 12px;
            color: #666;
            font-weight: bold;
            display: none;
        }

        .event-box {
            position: absolute;
            width: 150px;
            padding: 10px;
            background-color: var(--primary-color);
            color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            cursor: pointer;
            z-index: 2;
            transition: transform 0.2s;
        }

        .event-box:hover {
            transform: scale(1.05);
        }

        .event-date {
            font-weight: bold;
            font-size: 0.8rem;
        }

        .event-title {
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 10;
            overflow-y: auto;
        }

        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: var(--border-radius);
            width: 80%;
            max-width: 800px;
            position: relative;
        }

        .close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .modal-header {
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .modal-title {
            font-size: 1.5rem;
            color: var(--primary-color);
        }

        .modal-date {
            font-size: 0.9rem;
            color: #666;
        }

        .modal-description {
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .image-gallery {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            overflow-x: auto;
            padding-bottom: 10px;
        }

        .gallery-image {
            height: 100px;
            cursor: pointer;
            border-radius: 4px;
            transition: transform 0.2s;
        }

        .gallery-image:hover {
            transform: scale(1.05);
        }

        .fullscreen-image {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fullscreen-image img {
            max-width: 90%;
            max-height: 90%;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
            color: #666;
        }

        .error {
            background-color: #ffdddd;
            color: #d8000c;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .file-inputs {
                flex-direction: column;
            }
            
            .modal-content {
                width: 95%;
                margin: 5% auto;
            }
            
            .event-box {
                width: 120px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Timeline Visualizer</h1>
        <p>Upload your CSV and optional ZIP file to visualize events on a timeline.</p>
    </header>

    <div class="upload-container">
        <div class="file-inputs">
            <div class="file-input">
                <label for="csv-file">CSV File (required):</label>
                <input type="file" id="csv-file" accept=".csv">
            </div>
            <div class="file-input">
                <label for="zip-file">ZIP File (optional):</label>
                <input type="file" id="zip-file" accept=".zip">
            </div>
        </div>
        <button id="load-button">Load Timeline</button>
        <button id="load-default-button">Load Default Data</button>
        <div id="error-container"></div>
    </div>

    <div class="controls">
        <div class="toggle-container">
            <span>Colour by Type:</span>
            <label class="toggle-switch">
                <input type="checkbox" id="color-toggle" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div id="color-key-container" style="display: none;">
            <h3>Event Type Colour Key</h3>
            <ul id="color-key" style="list-style: none; padding: 0;"></ul>
        </div>
        <div id="color-key-container" style="margin: 10px 0;"></div>
    </div>

    <div id="timeline-container">
        <div id="loading" class="loading">Loading timeline...</div>
        <div id="timeline" class="timeline"></div>
    </div>

    <div id="event-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div class="modal-header">
                <h2 class="modal-title">Event Title</h2>
                <div class="modal-date">Event Date</div>
            </div>
            <div class="modal-description">Description will appear here.</div>
            <div class="image-gallery" id="image-gallery"></div>
        </div>
    </div>

    <div id="fullscreen-image-container" class="fullscreen-image">
        <img id="fullscreen-img" src="">
    </div>

    <script>
        // Global variables
        let eventData = [];
        let imageData = {};
        let colorByType = true;
        
        // DOM elements
        const csvFileInput = document.getElementById('csv-file');
        const zipFileInput = document.getElementById('zip-file');
        const loadButton = document.getElementById('load-button');
        const loadDefaultButton = document.getElementById('load-default-button');
        const colorToggle = document.getElementById('color-toggle');
        const timelineContainer = document.getElementById('timeline-container');
        const timeline = document.getElementById('timeline');
        const loading = document.getElementById('loading');
        const errorContainer = document.getElementById('error-container');
        const modal = document.getElementById('event-modal');
        const modalTitle = document.querySelector('.modal-title');
        const modalDate = document.querySelector('.modal-date');
        const modalDescription = document.querySelector('.modal-description');
        const imageGallery = document.getElementById('image-gallery');
        const fullscreenContainer = document.getElementById('fullscreen-image-container');
        const fullscreenImg = document.getElementById('fullscreen-img');
        
        // Hide loading initially
        loading.style.display = 'none';
        
        // Function to parse CSV data
        function parseCSV(text) {
            const lines = text.split('\n');
            const headers = lines[0].split(',').map(header => header.trim());
            
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;
                
                const values = lines[i].split(',');
                const entry = {};
                
                headers.forEach((header, index) => {
                    entry[header] = values[index] ? values[index].trim() : '';
                });
                
                data.push(entry);
            }
            
            return data;
        }
        
        // Function to parse ZIP file
        async function handleZipFile(file) {
            try {
                const JSZip = window.JSZip;
                if (!JSZip) {
                    throw new Error("JSZip library not loaded");
                }
                
                const zip = await JSZip.loadAsync(file);
                const imageData = {};
                
                // Process each folder in the zip file
                const processingPromises = [];
                
                zip.forEach((path, zipEntry) => {
                    if (!zipEntry.dir) {
                        const pathParts = path.split('/');
                        // Check if it's in a directory (ID folder)
                        if (pathParts.length > 1) {
                            const folderId = pathParts[0];
                            const fileName = pathParts[pathParts.length - 1];
                            
                            // Check if it's an image file
                            if (/\.(jpe?g|png|gif|bmp|webp)$/i.test(fileName)) {
                                if (!imageData[folderId]) {
                                    imageData[folderId] = [];
                                }
                                
                                const promise = zipEntry.async('base64').then(content => {
                                    const fileExt = fileName.split('.').pop().toLowerCase();
                                    const mimeType = {
                                        'jpg': 'image/jpeg',
                                        'jpeg': 'image/jpeg',
                                        'png': 'image/png',
                                        'gif': 'image/gif',
                                        'bmp': 'image/bmp',
                                        'webp': 'image/webp'
                                    }[fileExt] || 'image/jpeg';
                                    
                                    imageData[folderId].push({
                                        name: fileName,
                                        data: `data:${mimeType};base64,${content}`
                                    });
                                });
                                
                                processingPromises.push(promise);
                            }
                        }
                    }
                });
                
                await Promise.all(processingPromises);
                return imageData;
            } catch (error) {
                console.error('Error processing ZIP file:', error);
                showError('Error processing ZIP file: ' + error.message);
                return {};
            }
        }
        
        // Function to generate a color based on the event type
        function getTypeColor(type) {
            if (!type) return '#4a6fa5'; // Default color
            
            // Generate a consistent color based on the type string
            let hash = 0;
            for (let i = 0; i < type.length; i++) {
                hash = type.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            // Convert to HSL to ensure good saturation and lightness
            const h = Math.abs(hash) % 360;
            const s = 60 + (Math.abs(hash) % 20); // 60-80% saturation
            const l = 40 + (Math.abs(hash) % 15); // 40-55% lightness
            
            return `hsl(${h}, ${s}%, ${l}%)`;
        }

function generateColorKey() {
    const colorKeyContainer = document.getElementById('color-key-container');
    const colorKeyList = document.getElementById('color-key');

    // Clear any existing key
    colorKeyList.innerHTML = '';

    // Collect unique event types
    const uniqueTypes = [...new Set(eventData.map(event => event.TYPE).filter(type => type))];

    // If there are no types, hide the key
    if (uniqueTypes.length === 0) {
        colorKeyContainer.style.display = 'none';
        return;
    }

    // Otherwise, show the key and populate it
    colorKeyContainer.style.display = 'block';

    uniqueTypes.forEach(type => {
        const color = getTypeColor(type);
        
        const listItem = document.createElement('li');
        listItem.style.display = 'flex';
        listItem.style.alignItems = 'center';
        listItem.style.marginBottom = '5px';

        const colorBox = document.createElement('span');
        colorBox.style.display = 'inline-block';
        colorBox.style.width = '20px';
        colorBox.style.height = '20px';
        colorBox.style.backgroundColor = color;
        colorBox.style.border = '1px solid #ccc';
        colorBox.style.marginRight = '10px';
        colorBox.style.borderRadius = '4px';

        const label = document.createElement('span');
        label.textContent = type;

        listItem.appendChild(colorBox);
        listItem.appendChild(label);

        colorKeyList.appendChild(listItem);
    });
}

        // Function to display the timeline
function displayTimeline() {
    if (!eventData || eventData.length === 0) {
        showError('No event data to display.');
        return;
    }
    
    // Sort events by start date
    eventData.sort((a, b) => {
        const dateA = parseDate(a.START_DATE);
        const dateB = parseDate(b.START_DATE);
        return dateA - dateB;
    });
    
    // Clear the timeline
    timeline.innerHTML = '';
    
    // Calculate timeline dimensions
    const containerWidth = timelineContainer.clientWidth - 40; // Adjust for padding
    const eventBoxWidth = Math.min(150, containerWidth * 0.2);
    const eventBoxHeight = 70;
    const eventSpacing = 30;
    const rowHeight = eventBoxHeight + 60;
    const eventsPerRow = Math.max(3, Math.floor(containerWidth / (eventBoxWidth + eventSpacing)));
    
    // Find the earliest and latest dates
    let earliestDate = new Date();
    let latestDate = new Date(0);
    
    eventData.forEach(event => {
        const date = parseDate(event.START_DATE);
        if (date < earliestDate) earliestDate = date;
        if (date > latestDate) latestDate = date;
    });
    
    // Calculate start and end years
    const startYear = earliestDate.getFullYear();
    const endYear = latestDate.getFullYear();
    
    // Create year markers
    for (let year = startYear; year <= endYear; year++) {
        const yearPositions = calculateYearPosition(year, startYear, endYear, containerWidth, eventsPerRow, rowHeight);
        
        yearPositions.forEach(pos => {
            const marker = document.createElement('div');
            marker.className = 'year-marker';
            marker.style.left = `${pos.x}px`;
            marker.style.top = `${pos.y - 15}px`;
            marker.style.height = '15px';
            
            const label = document.createElement('div');
            label.className = 'year-label';
            label.style.left = `${pos.x - 15}px`;
            label.style.top = `${pos.y - 30}px`;
            label.textContent = year;
            
            timeline.appendChild(marker);
            timeline.appendChild(label);
        });
    }
    
    // Create timeline path segments
    const rowCount = Math.ceil(eventData.length / eventsPerRow);
    
    for (let row = 0; row < rowCount; row++) {
        const path = document.createElement('div');
        path.className = 'timeline-path';
        
        // Snake pattern - alternate left-to-right and right-to-left
        if (row % 2 === 0) {
            // Left to right
            path.style.left = '0';
            path.style.width = `${containerWidth}px`;
        } else {
            // Right to left
            path.style.left = '0';
            path.style.width = `${containerWidth}px`;
        }
        
        path.style.top = `${row * rowHeight + eventBoxHeight / 2}px`;
        timeline.appendChild(path);
        
        // Add vertical connectors between rows (except for the last row)
        if (row < rowCount - 1) {
            const connector = document.createElement('div');
            connector.className = 'timeline-connector';
            
            // Position depends on whether we're connecting from right-to-left or left-to-right
            if (row % 2 === 0) {
                // Current row is left-to-right, connect from right to left
                connector.style.left = `${containerWidth}px`;
            } else {
                // Current row is right-to-left, connect from left to right
                connector.style.left = `0px`;
            }
            
            // Set the vertical position and height to connect this row to the next
            connector.style.top = `${row * rowHeight + eventBoxHeight / 2}px`;
            connector.style.height = `${rowHeight}px`;
            
            timeline.appendChild(connector);
        }
    }
    
    // Calculate total timeline height and set it
    const totalHeight = rowCount * rowHeight;
    timeline.style.height = `${totalHeight}px`;
    
    // Create event boxes
    eventData.forEach((event, index) => {
        const row = Math.floor(index / eventsPerRow);
        const colInRow = index % eventsPerRow;
        
        // Calculate position based on snake pattern
        let left;
        if (row % 2 === 0) {
            // Left to right
            left = colInRow * (containerWidth / eventsPerRow);
        } else {
            // Right to left
            left = containerWidth - ((colInRow + 1) * (containerWidth / eventsPerRow)) + eventSpacing/2;
        }
        
        const top = row * rowHeight;
        
        // Create the event box
        const eventBox = document.createElement('div');
        eventBox.className = 'event-box';
        eventBox.style.left = `${left}px`;
        eventBox.style.top = `${top}px`;
        eventBox.style.width = `${eventBoxWidth}px`;
        eventBox.style.height = `${eventBoxHeight}px`;
        
        // Set color based on type if enabled
        if (colorByType && event.TYPE) {
            eventBox.style.backgroundColor = getTypeColor(event.TYPE);
        }
        if (colorByType) {
            generateColorKey();
        } else {
            document.getElementById('color-key-container').style.display = 'none';
        }

        
        // Add event content
        const dateElem = document.createElement('div');
        dateElem.className = 'event-date';
        dateElem.textContent = formatDate(parseDate(event.START_DATE));
        
        const titleElem = document.createElement('div');
        titleElem.className = 'event-title';
        titleElem.textContent = event.NAME || 'Unnamed Event';
        
        eventBox.appendChild(dateElem);
        eventBox.appendChild(titleElem);
        
        // Add click event to show modal
        eventBox.addEventListener('click', () => {
            showEventDetails(event);
        });
        
        timeline.appendChild(eventBox);
    });
}
        
        // Calculate where a year should appear on the snake timeline
        function calculateYearPosition(year, startYear, endYear, width, eventsPerRow, rowHeight) {
            const yearPositions = [];
            const yearRange = endYear - startYear;
            const yearFraction = (year - startYear) / Math.max(1, yearRange);
            
            // Calculate total number of events to position this year
            const totalEventPositions = width * (yearFraction);
            const rowPosition = Math.floor(totalEventPositions / width);
            const positionInRow = totalEventPositions % width;
            
            // If it's an even row, position from left to right
            // If it's an odd row, position from right to left
            let x;
            if (rowPosition % 2 === 0) {
                x = positionInRow;
            } else {
                x = width - positionInRow;
            }
            
            yearPositions.push({
                x: x,
                y: rowPosition * rowHeight
            });
            
            return yearPositions;
        }
        
        // Helper function to parse date strings (DD-MM-YYYY)
        function parseDate(dateString) {
            if (!dateString) return new Date(0);
            
            const parts = dateString.split('-');
            if (parts.length === 3) {
                // DD-MM-YYYY format
                return new Date(parts[2], parts[1] - 1, parts[0]);
            } else {
                // Try as ISO format if the split failed
                return new Date(dateString);
            }
        }
        
        // Helper function to format dates
        function formatDate(date) {
            if (!(date instanceof Date) || isNaN(date)) return 'Unknown Date';
            
            const day = date.getDate().toString().padStart(2, '0');
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const year = date.getFullYear();
            
            return `${day}-${month}-${year}`;
        }
        
        // Function to show error messages
        function showError(message) {
            errorContainer.innerHTML = `<div class="error">${message}</div>`;
        }
        
        // Function to clear error messages
        function clearError() {
            errorContainer.innerHTML = '';
        }
        
        // Function to show event details in a modal
        function showEventDetails(event) {
            modalTitle.textContent = event.NAME || 'Unnamed Event';
            modalDate.textContent = `${event.START_DATE || 'No date'}`;
            modalDescription.textContent = event.DESCRIPTION || 'No description available.';
            
            // Clear previous images
            imageGallery.innerHTML = '';
            
            // Add images if available
            const eventId = event.ID;
            if (imageData[eventId] && imageData[eventId].length > 0) {
                imageData[eventId].forEach(img => {
                    const imgElement = document.createElement('img');
                    imgElement.className = 'gallery-image';
                    imgElement.src = img.data;
                    imgElement.alt = img.name;
                    
                    imgElement.addEventListener('click', () => {
                        showFullscreenImage(img.data);
                    });
                    
                    imageGallery.appendChild(imgElement);
                });
            } else {
                imageGallery.innerHTML = '<p>No images available.</p>';
            }
            
            // Show the modal
            modal.style.display = 'block';
        }
        
        // Function to show a fullscreen image
        function showFullscreenImage(src) {
            fullscreenImg.src = src;
            fullscreenContainer.style.display = 'flex';
        }
        
        // Event listeners for the close buttons
        document.querySelector('.close').addEventListener('click', () => {
            modal.style.display = 'none';
        });
        
        fullscreenContainer.addEventListener('click', () => {
            fullscreenContainer.style.display = 'none';
        });
        
        // Close modal if clicking outside of content
        window.addEventListener('click', (event) => {
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        });
        
        // Toggle color by type
        colorToggle.addEventListener('change', () => {
            colorByType = colorToggle.checked;
            displayTimeline();
        });
        
        // Load button click event
        loadButton.addEventListener('click', async () => {
            const csvFile = csvFileInput.files[0];
            const zipFile = zipFileInput.files[0];
            
            clearError();
            
            if (!csvFile) {
                showError('Please select a CSV file.');
                return;
            }
            
            loading.style.display = 'block';
            
            try {
                // Load JSZip dynamically if needed
                if (zipFile && !window.JSZip) {
                    await loadJSZip();
                }
                
                // Read and parse CSV file
                const csvText = await csvFile.text();
                eventData = parseCSV(csvText);
                
                // Process ZIP file if provided
                if (zipFile) {
                    imageData = await handleZipFile(zipFile);
                } else {
                    imageData = {};
                }
                
                // Display the timeline
                displayTimeline();
            } catch (error) {
                console.error('Error loading files:', error);
                showError('Error loading files: ' + error.message);
            } finally {
                loading.style.display = 'none';
            }
        });
        
        // Load default data button click event
loadDefaultButton.addEventListener('click', async () => {
    clearError();
    loading.style.display = 'block';
    
    try {
        // Load JSZip dynamically if needed
        if (!window.JSZip) {
            await loadJSZip();
        }
        
        // Load default CSV data with proper error handling
        try {
            const csvResponse = await fetch('https://raw.githubusercontent.com/Connor-Sebastian-S/timeline_visualiser/main/timeline.csv');
            if (!csvResponse.ok) {
                throw new Error(`Failed to fetch CSV: ${csvResponse.status} ${csvResponse.statusText}`);
            }
            const csvText = await csvResponse.text();
            eventData = parseCSV(csvText);
        } catch (csvError) {
            console.error('Error loading default CSV:', csvError);
            showError('Error loading default CSV. Using empty dataset.');
            eventData = [];
        }
        
        // Reset image data if there's an error with the ZIP
        imageData = {};
        
        // Load default ZIP file with proper error handling
        try {
            const zipResponse = await fetch('https://raw.githubusercontent.com/Connor-Sebastian-S/timeline_visualiser/main/default.zip');
            if (!zipResponse.ok) {
                throw new Error(`Failed to fetch ZIP: ${zipResponse.status} ${zipResponse.statusText}`);
            }
            const zipBlob = await zipResponse.blob();
            imageData = await handleZipFile(zipBlob);
        } catch (zipError) {
            console.error('Error loading default ZIP:', zipError);
            showError('Error loading default images. Timeline will display without images.');
        }
        
        // Display the timeline even if only one of the files loaded successfully
        if (eventData.length > 0) {
            displayTimeline();
        } else {
            showError('No events to display. Please check the CSV file format.');
        }
    } catch (error) {
        console.error('Error in default data loading process:', error);
        showError('Error loading default data: ' + error.message);
    } finally {
        loading.style.display = 'none';
    }
});
        
        // Function to load JSZip library dynamically
        async function loadJSZip() {
            return new Promise((resolve, reject) => {
                if (window.JSZip) {
                    resolve();
                    return;
                }
                
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                script.onload = resolve;
                script.onerror = () => reject(new Error('Failed to load JSZip library'));
                document.head.appendChild(script);
            });
        }
        
        // Handle window resize to update the timeline layout
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (eventData.length > 0) {
                    displayTimeline();
                }
            }, 250);
        });
        
        // Load JSZip when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            loadJSZip().catch(error => {
                console.warn('JSZip preload failed, will try again when needed:', error);
            });
        });
    </script>
</body>
</html>
